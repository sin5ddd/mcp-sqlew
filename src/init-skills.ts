/**
 * Auto-initialize sqlew Rules on server startup
 *
 * As of v5.0.0, Skills and Hooks are managed by the sqlew-plugin (Claude Code Plugin).
 * This module now only handles:
 * - Global Rules initialization (~/.claude/rules/sqlew/)
 * - Project .gitignore updates
 *
 * @see https://github.com/sqlew-io/sqlew-plugin for Skills/Hooks/Agents
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { fileURLToPath } from 'url';
import { debugLog } from './utils/debug-logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Get path to assets directory (relative to dist/)
 */
function getAssetsPath(): string {
  const distDir = __dirname; // .../dist
  const packageRoot = path.dirname(distDir); // .../mcp-sqlew
  return path.join(packageRoot, 'assets');
}

/**
 * Get the global Claude rules directory
 * @returns Path to ~/.claude/rules/sqlew/
 */
function getGlobalRulesDir(): string {
  const home = os.homedir();
  return path.join(home, '.claude', 'rules', 'sqlew');
}

/**
 * Initialize Plan Mode Integration rule in global ~/.claude/rules/sqlew/ directory
 *
 * As of v5.0.0, rules are installed globally to apply across all projects.
 * This approach:
 * - Applies to all projects without per-project installation
 * - Survives plugin uninstall (user can manually delete if desired)
 * - No risk of corrupting user's CLAUDE.md content
 *
 * Global rules location: ~/.claude/rules/sqlew/plan-mode-integration.md
 */
export function initializeGlobalRules(): void {
  const snippetPath = path.join(getAssetsPath(), 'claude-md-snippets', 'plan-mode-integration.md');
  const globalRulesDir = getGlobalRulesDir();
  const targetPath = path.join(globalRulesDir, 'plan-mode-integration.md');

  // Check if snippet source exists
  if (!fs.existsSync(snippetPath)) {
    debugLog('WARN', 'Plan mode integration snippet not found', { snippetPath });
    return;
  }

  // Read snippet content
  const snippetContent = fs.readFileSync(snippetPath, 'utf-8');

  // Check if target already exists and is up-to-date
  if (fs.existsSync(targetPath)) {
    const currentContent = fs.readFileSync(targetPath, 'utf-8');
    if (currentContent === snippetContent) {
      debugLog('DEBUG', 'Global plan mode integration rule is already up-to-date');
      return;
    }
  }

  // Create global rules directory if needed
  try {
    fs.mkdirSync(globalRulesDir, { recursive: true });

    // Copy/update the rule file
    fs.writeFileSync(targetPath, snippetContent, 'utf-8');
    debugLog('INFO', 'Global plan mode integration rule initialized', { targetPath });
  } catch (error) {
    debugLog('WARN', 'Failed to initialize global plan mode integration rule', { error });
  }
}

/**
 * Initialize sqlew integrations on MCP server startup
 *
 * As of v5.0.0, Skills and Hooks are managed by the sqlew-plugin.
 * This function now only handles:
 * - Global Rules initialization (~/.claude/rules/sqlew/)
 * - Project .gitignore updates
 *
 * @param projectRoot - Project root directory (for .gitignore updates)
 */
export function initializeSqlewIntegrations(projectRoot: string): void {
  debugLog('DEBUG', 'Initializing sqlew integrations', { projectRoot });

  // Initialize global rules (~/.claude/rules/sqlew/)
  // This applies Plan Mode Integration across all projects
  initializeGlobalRules();

  // Initialize .gitignore entries for sqlew-generated files
  initializeGitignore(projectRoot);
}

/**
 * Files/directories auto-generated by sqlew that should be gitignored
 *
 * As of v5.0.0:
 * - Skills and Hooks are managed by sqlew-plugin (not per-project)
 * - Rules are installed globally (~/.claude/rules/sqlew/)
 * - Only sqlew working directories need gitignoring
 */
const SQLEW_GITIGNORE_ENTRIES = [
  '.sqlew/queue/',
  '.sqlew/tmp/',
  '.sqlew/*.db',
  '.sqlew/*.db-journal',
];

/** Marker comment for sqlew section in gitignore */
const SQLEW_GITIGNORE_MARKER = '# sqlew auto-generated files';

/**
 * Initialize .gitignore with sqlew auto-generated file entries
 * Creates .gitignore if it doesn't exist, adds missing entries if sqlew section exists
 */
export function initializeGitignore(projectRoot: string): void {
  const gitignorePath = path.join(projectRoot, '.gitignore');

  // Read current .gitignore content (or empty string if doesn't exist)
  let content = '';
  if (fs.existsSync(gitignorePath)) {
    content = fs.readFileSync(gitignorePath, 'utf-8');
  } else {
    debugLog('INFO', '.gitignore not found, creating new file', { gitignorePath });
  }

  // Check if sqlew section already exists
  if (content.includes(SQLEW_GITIGNORE_MARKER)) {
    // Find missing entries
    const missingEntries = SQLEW_GITIGNORE_ENTRIES.filter(entry => !content.includes(entry));

    if (missingEntries.length === 0) {
      debugLog('DEBUG', 'sqlew gitignore section is up-to-date');
      return;
    }

    // Append missing entries after the marker
    try {
      const markerIndex = content.indexOf(SQLEW_GITIGNORE_MARKER);
      const afterMarker = markerIndex + SQLEW_GITIGNORE_MARKER.length;
      const newContent =
        content.slice(0, afterMarker) +
        '\n' + missingEntries.join('\n') +
        content.slice(afterMarker);
      fs.writeFileSync(gitignorePath, newContent, 'utf-8');
      debugLog('INFO', 'Added missing sqlew entries to .gitignore', {
        entries: missingEntries
      });
    } catch (error) {
      debugLog('WARN', 'Failed to update .gitignore', { error });
    }
    return;
  }

  // Build section to add (fresh install)
  const sectionLines = [
    '',
    SQLEW_GITIGNORE_MARKER,
    ...SQLEW_GITIGNORE_ENTRIES,
  ];

  // Append to .gitignore
  try {
    const newContent = content.trimEnd() + '\n' + sectionLines.join('\n') + '\n';
    fs.writeFileSync(gitignorePath, newContent, 'utf-8');
    debugLog('INFO', 'Added sqlew entries to .gitignore', {
      entries: SQLEW_GITIGNORE_ENTRIES.length
    });
  } catch (error) {
    debugLog('WARN', 'Failed to update .gitignore', { error });
  }
}
