/**
 * Auto-initialize sqlew skills, CLAUDE.md integration, and hooks on server startup
 * Copies skills from assets if not present, appends to CLAUDE.md if section missing,
 * and sets up Claude Code hooks in settings.local.json (first time only)
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { debugLog } from './utils/debug-logger.js';
import { autoInitializeHooks } from './cli/hooks/init-hooks.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Get path to assets directory (relative to dist/)
 */
function getAssetsPath(): string {
  const distDir = __dirname; // .../dist
  const packageRoot = path.dirname(distDir); // .../mcp-sqlew
  return path.join(packageRoot, 'assets');
}

/**
 * Initialize skills in project's .claude/skills directory
 * Only copies if skill directory doesn't exist
 */
export function initializeSkills(projectRoot: string): void {
  const skillsSourceDir = path.join(getAssetsPath(), 'sample-skills');
  const skillsTargetDir = path.join(projectRoot, '.claude', 'skills');

  // Check if source exists
  if (!fs.existsSync(skillsSourceDir)) {
    debugLog('WARN', 'Skills source directory not found', { skillsSourceDir });
    return;
}

  // Get list of skill directories to copy
  const skillDirs = fs.readdirSync(skillsSourceDir, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  for (const skillName of skillDirs) {
    const sourceSkillDir = path.join(skillsSourceDir, skillName);
    const targetSkillDir = path.join(skillsTargetDir, skillName);

    // Only copy if target doesn't exist
    if (!fs.existsSync(targetSkillDir)) {
      try {
        // Create target directory
        fs.mkdirSync(targetSkillDir, { recursive: true });

        // Copy all files in skill directory
        const files = fs.readdirSync(sourceSkillDir);
        for (const file of files) {
          const sourceFile = path.join(sourceSkillDir, file);
          const targetFile = path.join(targetSkillDir, file);
          fs.copyFileSync(sourceFile, targetFile);
        }

        debugLog('INFO', `Skill initialized: ${skillName}`, { targetSkillDir });
      } catch (error) {
        debugLog('WARN', `Failed to initialize skill: ${skillName}`, { error });
      }
    }
}
}

/**
 * Initialize Plan Mode Integration rule in .claude/rules/ directory
 * This approach is safer than editing CLAUDE.md directly:
 * - Files in .claude/rules/ are auto-loaded with same priority as CLAUDE.md
 * - No risk of corrupting user's CLAUDE.md content
 * - Simple file copy/overwrite for updates
 */
export function initializeRules(projectRoot: string): void {
  const snippetPath = path.join(getAssetsPath(), 'claude-md-snippets', 'plan-mode-integration.md');
  const rulesDir = path.join(projectRoot, '.claude', 'rules');
  const targetPath = path.join(rulesDir, 'plan-mode-integration.md');

  // Check if snippet source exists
  if (!fs.existsSync(snippetPath)) {
    debugLog('WARN', 'Plan mode integration snippet not found', { snippetPath });
    return;
  }

  // Read snippet content
  const snippetContent = fs.readFileSync(snippetPath, 'utf-8');

  // Check if target already exists and is up-to-date
  if (fs.existsSync(targetPath)) {
    const currentContent = fs.readFileSync(targetPath, 'utf-8');
    if (currentContent === snippetContent) {
      debugLog('DEBUG', 'Plan mode integration rule is already up-to-date');
      return;
    }
  }

  // Create rules directory if needed
  try {
    fs.mkdirSync(rulesDir, { recursive: true });

    // Copy/update the rule file
    fs.writeFileSync(targetPath, snippetContent, 'utf-8');
    debugLog('INFO', 'Plan mode integration rule initialized', { targetPath });
  } catch (error) {
    debugLog('WARN', 'Failed to initialize plan mode integration rule', { error });
  }
}

/**
 * Initialize all sqlew integrations (skills + rules + hooks + gitignore)
 * Called during server startup
 */
export function initializeSqlewIntegrations(projectRoot: string): void {
  debugLog('DEBUG', 'Initializing sqlew integrations', { projectRoot });

  // Initialize skills
  initializeSkills(projectRoot);

  // Initialize .claude/rules/ for Plan Mode Integration
  initializeRules(projectRoot);

  // Initialize Claude Code hooks (first time only)
  const hooksInitialized = autoInitializeHooks(projectRoot);
  if (hooksInitialized) {
    debugLog('INFO', 'Claude Code hooks auto-initialized', { projectRoot });
}

  // Initialize .gitignore entries for auto-generated files
  initializeGitignore(projectRoot);
}

/**
 * Files/directories auto-generated by sqlew that should be gitignored
 * These are installed per-project and shouldn't be committed
 */
const SQLEW_GITIGNORE_ENTRIES = [
  '.claude/skills/sqlew-decision-format/',
  '.claude/skills/sqlew-plan-guidance/',
  '.claude/rules/plan-mode-integration.md',
  '.claude/commands/sqlew.md',
];

/** Marker comment for sqlew section in gitignore */
const SQLEW_GITIGNORE_MARKER = '# sqlew auto-generated files';

/**
 * Initialize .gitignore with sqlew auto-generated file entries
 * Creates .gitignore if it doesn't exist, adds missing entries if sqlew section exists
 */
export function initializeGitignore(projectRoot: string): void {
  const gitignorePath = path.join(projectRoot, '.gitignore');

  // Read current .gitignore content (or empty string if doesn't exist)
  let content = '';
  if (fs.existsSync(gitignorePath)) {
    content = fs.readFileSync(gitignorePath, 'utf-8');
  } else {
    debugLog('INFO', '.gitignore not found, creating new file', { gitignorePath });
  }

  // Check if sqlew section already exists
  if (content.includes(SQLEW_GITIGNORE_MARKER)) {
    // Find missing entries
    const missingEntries = SQLEW_GITIGNORE_ENTRIES.filter(entry => !content.includes(entry));

    if (missingEntries.length === 0) {
      debugLog('DEBUG', 'sqlew gitignore section is up-to-date');
      return;
    }

    // Append missing entries after the marker
    try {
      const markerIndex = content.indexOf(SQLEW_GITIGNORE_MARKER);
      const afterMarker = markerIndex + SQLEW_GITIGNORE_MARKER.length;
      const newContent =
        content.slice(0, afterMarker) +
        '\n' + missingEntries.join('\n') +
        content.slice(afterMarker);
      fs.writeFileSync(gitignorePath, newContent, 'utf-8');
      debugLog('INFO', 'Added missing sqlew entries to .gitignore', {
        entries: missingEntries
      });
    } catch (error) {
      debugLog('WARN', 'Failed to update .gitignore', { error });
    }
    return;
  }

  // Build section to add (fresh install)
  const sectionLines = [
    '',
    SQLEW_GITIGNORE_MARKER,
    ...SQLEW_GITIGNORE_ENTRIES,
  ];

  // Append to .gitignore
  try {
    const newContent = content.trimEnd() + '\n' + sectionLines.join('\n') + '\n';
    fs.writeFileSync(gitignorePath, newContent, 'utf-8');
    debugLog('INFO', 'Added sqlew entries to .gitignore', {
      entries: SQLEW_GITIGNORE_ENTRIES.length
    });
  } catch (error) {
    debugLog('WARN', 'Failed to update .gitignore', { error });
  }
}
