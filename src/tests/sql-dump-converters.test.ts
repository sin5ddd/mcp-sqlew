/**
 * Unit tests for SQL dump converter functions
 *
 * Tests regex pattern conversions for cross-database SQL migration
 */

import { describe, it } from 'node:test';
import assert from 'node:assert';
import {
  convertIdentifierQuotes,
  convertAutoIncrement,
  convertTimestampFunctions,
  convertBooleanDefaults,
  convertDataTypes,
  removeCheckConstraints,
  removeSqliteDefaultFunctions,
} from '../utils/sql-dump-converters.js';

describe('SQL Dump Converters', () => {
  describe('convertIdentifierQuotes', () => {
    it('should convert double quotes to backticks for MySQL', () => {
      const input = 'CREATE TABLE "users" ("id" INTEGER, "name" TEXT)';
      const expected = 'CREATE TABLE `users` (`id` INTEGER, `name` TEXT)';
      assert.strictEqual(convertIdentifierQuotes(input, 'mysql'), expected);
    });

    it('should convert backticks to double quotes for PostgreSQL', () => {
      const input = 'CREATE TABLE `users` (`id` INT, `name` VARCHAR)';
      const expected = 'CREATE TABLE "users" ("id" INT, "name" VARCHAR)';
      assert.strictEqual(convertIdentifierQuotes(input, 'postgresql'), expected);
    });

    it('should convert backticks to double quotes for SQLite', () => {
      const input = 'CREATE TABLE `users` (`id` INT)';
      const expected = 'CREATE TABLE "users" ("id" INT)';
      assert.strictEqual(convertIdentifierQuotes(input, 'sqlite'), expected);
    });

    it('should handle identifiers with dots and hyphens (PostgreSQL)', () => {
      const input = 'SELECT `schema.table`, `my-column` FROM `table`';
      const expected = 'SELECT "schema.table", "my-column" FROM "table"';
      assert.strictEqual(convertIdentifierQuotes(input, 'postgresql'), expected);
    });

    it('should handle empty string', () => {
      assert.strictEqual(convertIdentifierQuotes('', 'mysql'), '');
    });

    it('should handle SQL with no identifier quotes', () => {
      const input = 'SELECT * FROM users';
      assert.strictEqual(convertIdentifierQuotes(input, 'mysql'), input);
    });
  });

  describe('convertAutoIncrement', () => {
    it('should convert AUTOINCREMENT to AUTO_INCREMENT (SQLite → MySQL)', () => {
      const input = 'id INTEGER PRIMARY KEY AUTOINCREMENT';
      const expected = 'id INTEGER PRIMARY KEY AUTO_INCREMENT';
      assert.strictEqual(convertAutoIncrement(input, 'sqlite', 'mysql'), expected);
    });

    it('should convert AUTOINCREMENT to GENERATED BY DEFAULT AS IDENTITY (SQLite → PostgreSQL)', () => {
      const input = 'id INTEGER AUTOINCREMENT';
      const expected = 'id INTEGER GENERATED BY DEFAULT AS IDENTITY';
      assert.strictEqual(convertAutoIncrement(input, 'sqlite', 'postgresql'), expected);
    });

    it('should convert INTEGER PRIMARY KEY AUTOINCREMENT to SERIAL PRIMARY KEY (SQLite → PostgreSQL)', () => {
      const input = 'id INTEGER PRIMARY KEY AUTOINCREMENT';
      const expected = 'id SERIAL PRIMARY KEY';
      assert.strictEqual(convertAutoIncrement(input, 'sqlite', 'postgresql'), expected);
    });

    it('should convert AUTO_INCREMENT to AUTOINCREMENT (MySQL → SQLite)', () => {
      const input = 'id INT PRIMARY KEY AUTO_INCREMENT';
      const expected = 'id INT PRIMARY KEY AUTOINCREMENT';
      assert.strictEqual(convertAutoIncrement(input, 'mysql', 'sqlite'), expected);
    });

    it('should convert AUTO_INCREMENT to GENERATED ALWAYS AS IDENTITY (MySQL → PostgreSQL)', () => {
      const input = 'id INT AUTO_INCREMENT';
      const expected = 'id INT GENERATED ALWAYS AS IDENTITY';
      assert.strictEqual(convertAutoIncrement(input, 'mysql', 'postgresql'), expected);
    });

    it('should convert SERIAL to INTEGER (PostgreSQL → SQLite)', () => {
      const input = 'id SERIAL PRIMARY KEY';
      const expected = 'id INTEGER PRIMARY KEY';
      assert.strictEqual(convertAutoIncrement(input, 'postgresql', 'sqlite'), expected);
    });

    it('should convert GENERATED BY DEFAULT AS IDENTITY to AUTOINCREMENT (PostgreSQL → SQLite)', () => {
      const input = 'id INTEGER GENERATED BY DEFAULT AS IDENTITY';
      const expected = 'id INTEGER AUTOINCREMENT';
      assert.strictEqual(convertAutoIncrement(input, 'postgresql', 'sqlite'), expected);
    });

    it('should convert SERIAL to INT (PostgreSQL → MySQL)', () => {
      const input = 'id SERIAL PRIMARY KEY';
      const expected = 'id INT PRIMARY KEY';
      assert.strictEqual(convertAutoIncrement(input, 'postgresql', 'mysql'), expected);
    });

    it('should be case insensitive', () => {
      const input = 'id INTEGER autoincrement';
      const expected = 'id INTEGER AUTO_INCREMENT';
      assert.strictEqual(convertAutoIncrement(input, 'sqlite', 'mysql'), expected);
    });

    it('should handle no autoincrement keywords', () => {
      const input = 'id INTEGER';
      assert.strictEqual(convertAutoIncrement(input, 'sqlite', 'mysql'), input);
    });
  });

  describe('convertTimestampFunctions', () => {
    it('should convert unixepoch() to UNIX_TIMESTAMP() (SQLite → MySQL)', () => {
      const input = 'SELECT unixepoch() AS current_time';
      const expected = 'SELECT UNIX_TIMESTAMP() AS current_time';
      assert.strictEqual(convertTimestampFunctions(input, 'mysql'), expected);
    });

    it('should convert datetime(ts, \'unixepoch\') to FROM_UNIXTIME(ts) (SQLite → MySQL)', () => {
      const input = "SELECT datetime(created_at, 'unixepoch')";
      const expected = 'SELECT FROM_UNIXTIME(created_at)';
      assert.strictEqual(convertTimestampFunctions(input, 'mysql'), expected);
    });

    it('should convert unixepoch() to extract(epoch from now())::integer (SQLite → PostgreSQL)', () => {
      const input = 'SELECT unixepoch()';
      const expected = 'SELECT extract(epoch from now())::integer';
      assert.strictEqual(convertTimestampFunctions(input, 'postgresql'), expected);
    });

    it('should convert datetime(ts, \'unixepoch\') to to_timestamp(ts) (SQLite → PostgreSQL)', () => {
      const input = "SELECT datetime(ts, 'unixepoch')";
      const expected = 'SELECT to_timestamp(ts)';
      assert.strictEqual(convertTimestampFunctions(input, 'postgresql'), expected);
    });

    it('should convert UNIX_TIMESTAMP() to unixepoch() (MySQL → SQLite)', () => {
      const input = 'SELECT UNIX_TIMESTAMP()';
      const expected = 'SELECT unixepoch()';
      assert.strictEqual(convertTimestampFunctions(input, 'sqlite'), expected);
    });

    it('should convert FROM_UNIXTIME(ts) to datetime(ts, \'unixepoch\') (MySQL → SQLite)', () => {
      const input = 'SELECT FROM_UNIXTIME(created_at)';
      const expected = "SELECT datetime(created_at, 'unixepoch')";
      assert.strictEqual(convertTimestampFunctions(input, 'sqlite'), expected);
    });

    it('should convert extract(epoch from now())::integer to unixepoch() (PostgreSQL → SQLite)', () => {
      const input = 'SELECT extract(epoch from now())::integer';
      const expected = 'SELECT unixepoch()';
      assert.strictEqual(convertTimestampFunctions(input, 'sqlite'), expected);
    });

    it('should handle multiple function conversions in one statement', () => {
      const input = "SELECT unixepoch(), datetime(ts, 'unixepoch')";
      const expected = 'SELECT UNIX_TIMESTAMP(), FROM_UNIXTIME(ts)';
      assert.strictEqual(convertTimestampFunctions(input, 'mysql'), expected);
    });

    it('should handle empty string', () => {
      assert.strictEqual(convertTimestampFunctions('', 'mysql'), '');
    });
  });

  describe('convertBooleanDefaults', () => {
    it('should convert boolean default \'0\' to false (PostgreSQL)', () => {
      const input = "is_active BOOLEAN default '0'";
      const expected = 'is_active boolean default false';
      assert.strictEqual(convertBooleanDefaults(input, 'postgresql'), expected);
    });

    it('should convert boolean default \'1\' to true (PostgreSQL)', () => {
      const input = "is_active BOOLEAN default '1'";
      const expected = 'is_active boolean default true';
      assert.strictEqual(convertBooleanDefaults(input, 'postgresql'), expected);
    });

    it('should convert boolean default 0 to false (PostgreSQL)', () => {
      const input = 'is_active BOOLEAN default 0';
      const expected = 'is_active boolean default false';
      assert.strictEqual(convertBooleanDefaults(input, 'postgresql'), expected);
    });

    it('should convert boolean default 1 to true (PostgreSQL)', () => {
      const input = 'is_active BOOLEAN default 1';
      const expected = 'is_active boolean default true';
      assert.strictEqual(convertBooleanDefaults(input, 'postgresql'), expected);
    });

    it('should be case insensitive', () => {
      const input = 'is_active boolean DEFAULT 1';
      const expected = 'is_active boolean default true';
      assert.strictEqual(convertBooleanDefaults(input, 'postgresql'), expected);
    });

    it('should not convert for MySQL or SQLite', () => {
      const input = "is_active BOOLEAN default '1'";
      assert.strictEqual(convertBooleanDefaults(input, 'mysql'), input);
      assert.strictEqual(convertBooleanDefaults(input, 'sqlite'), input);
    });

    it('should handle multiple boolean columns', () => {
      const input = "is_active BOOLEAN default '1', is_deleted BOOLEAN default '0'";
      const expected = 'is_active boolean default true, is_deleted boolean default false';
      assert.strictEqual(convertBooleanDefaults(input, 'postgresql'), expected);
    });
  });

  describe('convertDataTypes', () => {
    it('should convert TEXT with default to VARCHAR(255) (MySQL)', () => {
      const input = "name TEXT default 'anonymous'";
      const expected = "name VARCHAR(255) default 'anonymous'";
      assert.strictEqual(convertDataTypes(input, 'mysql'), expected);
    });

    it('should convert TEXT NOT NULL with default to VARCHAR(255) (MySQL)', () => {
      const input = "name TEXT NOT NULL default 'anonymous'";
      const expected = "name VARCHAR(255) NOT NULL default 'anonymous'";
      assert.strictEqual(convertDataTypes(input, 'mysql'), expected);
    });

    it('should not convert TEXT without default (MySQL)', () => {
      const input = 'description TEXT';
      assert.strictEqual(convertDataTypes(input, 'mysql'), input);
    });

    it('should convert datetime to TIMESTAMP (PostgreSQL)', () => {
      const input = 'created_at datetime';
      const expected = 'created_at TIMESTAMP';
      assert.strictEqual(convertDataTypes(input, 'postgresql'), expected);
    });

    it('should be case insensitive for TEXT', () => {
      const input = "name text default 'test'";
      const expected = "name VARCHAR(255) default 'test'";
      assert.strictEqual(convertDataTypes(input, 'mysql'), expected);
    });

    it('should handle multiple columns', () => {
      const input = "name TEXT default 'anon', status TEXT default 'active'";
      const expected = "name VARCHAR(255) default 'anon', status VARCHAR(255) default 'active'";
      assert.strictEqual(convertDataTypes(input, 'mysql'), expected);
    });

    it('should not convert for SQLite', () => {
      const input = 'created_at datetime';
      assert.strictEqual(convertDataTypes(input, 'sqlite'), input);
    });
  });

  describe('removeCheckConstraints', () => {
    it('should remove simple CHECK constraint', () => {
      const input = 'CREATE TABLE t (id INT check (id > 0))';
      const expected = 'CREATE TABLE t (id INT)';
      assert.strictEqual(removeCheckConstraints(input), expected);
    });

    it('should remove CHECK constraint with nested parentheses', () => {
      const input = "CREATE TABLE t (status TEXT check (status in ('active', 'inactive')))";
      const expected = 'CREATE TABLE t (status TEXT)';
      assert.strictEqual(removeCheckConstraints(input), expected);
    });

    it('should remove multiple CHECK constraints', () => {
      const input = "id INT check (id > 0), name TEXT check (length(name) > 0)";
      const expected = 'id INT, name TEXT';
      assert.strictEqual(removeCheckConstraints(input), expected);
    });

    it('should be case insensitive', () => {
      const input = 'id INT CHECK (id > 0)';
      const expected = 'id INT';
      assert.strictEqual(removeCheckConstraints(input), expected);
    });

    it('should handle complex nested constraints', () => {
      const input = "priority INTEGER check (priority in (1, 2, 3))";
      const expected = 'priority INTEGER';
      assert.strictEqual(removeCheckConstraints(input), expected);
    });

    it('should handle SQL with no CHECK constraints', () => {
      const input = 'CREATE TABLE t (id INT, name TEXT)';
      assert.strictEqual(removeCheckConstraints(input), input);
    });

    it('should handle empty string', () => {
      assert.strictEqual(removeCheckConstraints(''), '');
    });
  });

  describe('removeSqliteDefaultFunctions', () => {
    it('should remove default (strftime(...)) function', () => {
      const input = "created_at INTEGER default (strftime('%s', 'now'))";
      const expected = 'created_at INTEGER default 0';
      assert.strictEqual(removeSqliteDefaultFunctions(input), expected);
    });

    it('should remove default strftime(...) function (no parens)', () => {
      const input = "created_at INTEGER default strftime('%s', 'now')";
      const expected = 'created_at INTEGER default 0';
      assert.strictEqual(removeSqliteDefaultFunctions(input), expected);
    });

    it('should remove multiple strftime functions', () => {
      const input = "created_at INTEGER default (strftime('%s', 'now')), updated_at INTEGER default strftime('%s', 'now')";
      const expected = 'created_at INTEGER default 0, updated_at INTEGER default 0';
      assert.strictEqual(removeSqliteDefaultFunctions(input), expected);
    });

    it('should be case insensitive', () => {
      const input = "created_at INTEGER DEFAULT (STRFTIME('%s', 'now'))";
      const expected = 'created_at INTEGER default 0';
      assert.strictEqual(removeSqliteDefaultFunctions(input), expected);
    });

    it('should handle SQL with no strftime functions', () => {
      const input = 'created_at INTEGER default 0';
      assert.strictEqual(removeSqliteDefaultFunctions(input), input);
    });

    it('should handle empty string', () => {
      assert.strictEqual(removeSqliteDefaultFunctions(''), '');
    });
  });

  describe('Edge cases and integration', () => {
    it('should handle combined conversions (SQLite → MySQL)', () => {
      let sql = 'CREATE TABLE "users" ("id" INTEGER AUTOINCREMENT, "name" TEXT default \'test\')';
      sql = convertIdentifierQuotes(sql, 'mysql');
      sql = convertAutoIncrement(sql, 'sqlite', 'mysql');
      sql = convertDataTypes(sql, 'mysql');

      const expected = 'CREATE TABLE `users` (`id` INTEGER AUTO_INCREMENT, `name` VARCHAR(255) default \'test\')';
      assert.strictEqual(sql, expected);
    });

    it('should handle combined conversions (SQLite → PostgreSQL)', () => {
      let sql = 'CREATE TABLE "users" ("id" INTEGER AUTOINCREMENT, "active" BOOLEAN default 1)';
      sql = convertIdentifierQuotes(sql, 'postgresql');
      sql = convertAutoIncrement(sql, 'sqlite', 'postgresql');
      sql = convertBooleanDefaults(sql, 'postgresql');

      const expected = 'CREATE TABLE "users" ("id" INTEGER GENERATED BY DEFAULT AS IDENTITY, "active" boolean default true)';
      assert.strictEqual(sql, expected);
    });

    it('should handle view conversions with timestamp functions', () => {
      let sql = 'CREATE VIEW v_recent AS SELECT unixepoch() as ts';
      sql = convertTimestampFunctions(sql, 'mysql');

      const expected = 'CREATE VIEW v_recent AS SELECT UNIX_TIMESTAMP() as ts';
      assert.strictEqual(sql, expected);
    });

    it('should handle empty SQL gracefully', () => {
      assert.strictEqual(convertIdentifierQuotes('', 'mysql'), '');
      assert.strictEqual(convertAutoIncrement('', 'sqlite', 'mysql'), '');
      assert.strictEqual(convertTimestampFunctions('', 'mysql'), '');
      assert.strictEqual(convertBooleanDefaults('', 'postgresql'), '');
      assert.strictEqual(convertDataTypes('', 'mysql'), '');
      assert.strictEqual(removeCheckConstraints(''), '');
      assert.strictEqual(removeSqliteDefaultFunctions(''), '');
    });

    it('should handle SQL with no matches gracefully', () => {
      const sql = 'SELECT * FROM users WHERE id = 1';
      assert.strictEqual(convertIdentifierQuotes(sql, 'mysql'), sql);
      assert.strictEqual(convertAutoIncrement(sql, 'sqlite', 'mysql'), sql);
      assert.strictEqual(convertTimestampFunctions(sql, 'mysql'), sql);
      assert.strictEqual(convertBooleanDefaults(sql, 'postgresql'), sql);
      assert.strictEqual(convertDataTypes(sql, 'mysql'), sql);
      assert.strictEqual(removeCheckConstraints(sql), sql);
      assert.strictEqual(removeSqliteDefaultFunctions(sql), sql);
    });
  });
});
