/**
 * Test suite for agent reuse system
 * Tests generic agent slot reuse and user-specified agent preservation
 */

import { describe, it, beforeEach, afterEach } from 'node:test';
import assert from 'node:assert';
import type { DatabaseAdapter } from '../adapters/types.js';
import { initializeDatabase, getOrCreateAgent, updateAgentActivity, closeDatabase } from '../database.js';
import { releaseInactiveAgents } from '../utils/retention.js';
import { clearOldData } from '../tools/utils.js';

describe('Agent Reuse System', () => {
  let adapter: DatabaseAdapter;

  beforeEach(async () => {
    adapter = await initializeDatabase({
      databaseType: 'sqlite',
      connection: { filename: ':memory:' }
    });
  });

  afterEach(async () => {
    await closeDatabase();
  });

  describe('User-specified agents', () => {
    it('should create user-specified agents as non-reusable', async () => {
      const agentId = await getOrCreateAgent(adapter, 'rust-expert');

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.strictEqual(agent.name, 'rust-expert');
      assert.strictEqual(agent.is_reusable, 0); // SQLite stores false as 0
      assert.strictEqual(agent.in_use, 1); // SQLite stores true as 1
      assert.ok(agent.last_active_ts > 0);
    });

    it('should preserve user-specified agent names', async () => {
      const agentId1 = await getOrCreateAgent(adapter, 'typescript-expert');
      const agentId2 = await getOrCreateAgent(adapter, 'typescript-expert');

      assert.strictEqual(agentId1, agentId2);

      const count = await adapter.getKnex()('m_agents')
        .where({ name: 'typescript-expert' })
        .count('* as count')
        .first();

      assert.strictEqual(count?.count, 1);
    });

    it('should update activity timestamp on reuse', async () => {
      const agentId1 = await getOrCreateAgent(adapter, 'scrum-master');
      const agent1 = await adapter.getKnex()('m_agents')
        .where({ id: agentId1 })
        .first();

      // Wait a moment
      await new Promise(resolve => setTimeout(resolve, 100));

      const agentId2 = await getOrCreateAgent(adapter, 'scrum-master');
      const agent2 = await adapter.getKnex()('m_agents')
        .where({ id: agentId2 })
        .first();

      assert.strictEqual(agentId1, agentId2);
      assert.ok(agent2.last_active_ts >= agent1.last_active_ts);
    });
  });

  describe('Generic agents', () => {
    it('should create first generic agent as generic-1', async () => {
      const agentId = await getOrCreateAgent(adapter, '');

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.strictEqual(agent.name, 'generic-1');
      assert.strictEqual(agent.is_reusable, 1);
      assert.strictEqual(agent.in_use, 1);
    });

    it('should create multiple generic agents sequentially', async () => {
      const agentId1 = await getOrCreateAgent(adapter, '');
      const agentId2 = await getOrCreateAgent(adapter, '');
      const agentId3 = await getOrCreateAgent(adapter, '');

      const agents = await adapter.getKnex()('m_agents')
        .whereIn('id', [agentId1, agentId2, agentId3])
        .orderBy('id');

      assert.strictEqual(agents[0].name, 'generic-1');
      assert.strictEqual(agents[1].name, 'generic-2');
      assert.strictEqual(agents[2].name, 'generic-3');
      agents.forEach(agent => {
        assert.strictEqual(agent.is_reusable, 1);
        assert.strictEqual(agent.in_use, 1);
      });
    });

    it('should reuse released generic agent slots', async () => {
      const agentId1 = await getOrCreateAgent(adapter, '');
      const agentId2 = await getOrCreateAgent(adapter, '');

      // Release the first agent
      await releaseAgent(adapter, agentId1);

      // Next generic agent request should reuse slot 1
      const agentId3 = await getOrCreateAgent(adapter, '');

      assert.strictEqual(agentId3, agentId1);

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId3 })
        .first();

      assert.strictEqual(agent.name, 'generic-1');
      assert.strictEqual(agent.in_use, 1);
    });

    it('should recognize generic-N pattern as reusable', async () => {
      const agentId = await getOrCreateAgent(adapter, 'generic-5');

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.strictEqual(agent.name, 'generic-5');
      assert.strictEqual(agent.is_reusable, 1);
    });

    it('should recognize agent-N pattern as reusable', async () => {
      const agentId = await getOrCreateAgent(adapter, 'agent-123');

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.strictEqual(agent.name, 'agent-123');
      assert.strictEqual(agent.is_reusable, 1);
    });

    it('should recognize subagent-N pattern as reusable', async () => {
      const agentId = await getOrCreateAgent(adapter, 'subagent-42');

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.strictEqual(agent.name, 'subagent-42');
      assert.strictEqual(agent.is_reusable, 1);
    });
  });

  describe('Agent release and cleanup', () => {
    it('should mark generic agent as not in use', async () => {
      const agentId = await getOrCreateAgent(adapter, '');

      await releaseAgent(adapter, agentId);

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.strictEqual(agent.in_use, 0);
    });

    it('should not release user-specified agents', async () => {
      const agentId = await getOrCreateAgent(adapter, 'important-agent');

      await releaseAgent(adapter, agentId);

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      // User-specified agents (is_reusable=false) should not be released
      assert.strictEqual(agent.in_use, 1);
    });

    it('should release inactive agents after timeout', async () => {
      const agentId1 = await getOrCreateAgent(adapter, '');
      const agentId2 = await getOrCreateAgent(adapter, '');

      // Set agent1 as inactive (old timestamp)
      const oldTimestamp = Math.floor(Date.now() / 1000) - (25 * 3600); // 25 hours ago
      await adapter.getKnex()('m_agents')
        .where({ id: agentId1 })
        .update({ last_active_ts: oldTimestamp });

      // Release inactive agents (24 hour threshold)
      const releasedCount = await releaseInactiveAgents(adapter, 24);

      assert.strictEqual(releasedCount, 1);

      const agent1 = await adapter.getKnex()('m_agents')
        .where({ id: agentId1 })
        .first();
      const agent2 = await adapter.getKnex()('m_agents')
        .where({ id: agentId2 })
        .first();

      assert.strictEqual(agent1.in_use, 0);
      assert.strictEqual(agent2.in_use, 1);
    });

    it('should update agent activity timestamp', async () => {
      const agentId = await getOrCreateAgent(adapter, 'test-agent');
      const initialAgent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      await new Promise(resolve => setTimeout(resolve, 100));

      await updateAgentActivity(adapter, agentId);

      const updatedAgent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.ok(updatedAgent.last_active_ts > initialAgent.last_active_ts);
    });
  });

  describe('Integration with cleanup', () => {
    it('should include agent release in clearOldData', async () => {
      // Create some generic agents
      const agentId1 = await getOrCreateAgent(adapter, '');
      const agentId2 = await getOrCreateAgent(adapter, '');
      const agentId3 = await getOrCreateAgent(adapter, '');

      // Set agent1 and agent2 as old
      const oldTimestamp = Math.floor(Date.now() / 1000) - (25 * 3600);
      await adapter.getKnex()('m_agents')
        .whereIn('id', [agentId1, agentId2])
        .update({ last_active_ts: oldTimestamp });

      // Run cleanup
      const result = await clearOldData(undefined, adapter);

      assert.strictEqual(result.agents_released, 2);
      assert.strictEqual(result.success, true);

      const agents = await adapter.getKnex()('m_agents')
        .whereIn('id', [agentId1, agentId2, agentId3]);

      assert.strictEqual(agents[0].in_use, false);
      assert.strictEqual(agents[1].in_use, false);
      assert.strictEqual(agents[2].in_use, true);
    });
  });

  describe('Edge cases', () => {
    it('should handle mixed user and generic agents', async () => {
      const userAgent = await getOrCreateAgent(adapter, 'custom-agent');
      const genericAgent1 = await getOrCreateAgent(adapter, '');
      const genericAgent2 = await getOrCreateAgent(adapter, 'agent-5');

      const agents = await adapter.getKnex()('m_agents')
        .orderBy('id');

      assert.strictEqual(agents.length, 3);
      assert.strictEqual(agents[0].is_reusable, 0); // custom-agent
      assert.strictEqual(agents[1].is_reusable, 1);  // generic-1
      assert.strictEqual(agents[2].is_reusable, 1);  // agent-5
    });

    it('should handle concurrent agent creation', async () => {
      // Create multiple agents concurrently
      const promises = [
        getOrCreateAgent(adapter, ''),
        getOrCreateAgent(adapter, ''),
        getOrCreateAgent(adapter, ''),
      ];

      const agentIds = await Promise.all(promises);

      // All should be created (no slot reuse since all concurrent)
      assert.strictEqual(agentIds.length, 3);
      assert.strictEqual(new Set(agentIds).size, 3); // All unique

      const agents = await adapter.getKnex()('m_agents')
        .whereIn('id', agentIds)
        .orderBy('name');

      assert.strictEqual(agents[0].name, 'generic-1');
      assert.strictEqual(agents[1].name, 'generic-2');
      assert.strictEqual(agents[2].name, 'generic-3');
    });

    it('should handle empty string as generic', async () => {
      const agentId = await getOrCreateAgent(adapter, '');

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.strictEqual(agent.is_reusable, 1);
      assert.strictEqual(agent.name, 'generic-1');
    });

    it('should preserve system agent as non-reusable', async () => {
      const agentId = await getOrCreateAgent(adapter, 'system');

      const agent = await adapter.getKnex()('m_agents')
        .where({ id: agentId })
        .first();

      assert.strictEqual(agent.name, 'system');
      assert.strictEqual(agent.is_reusable, 0);
    });
  });
});
