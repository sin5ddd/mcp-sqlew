// sql-dump-converters.ts - Shared SQL syntax conversion functions

export type DatabaseFormat = 'mysql' | 'postgresql' | 'sqlite';

/**
 * Convert identifier quotes between database formats
 *
 * Database-specific identifier quoting:
 * - MySQL: backticks `identifier`
 * - PostgreSQL: double quotes "identifier"
 * - SQLite: double quotes "identifier" (also supports backticks)
 *
 * @param sql - SQL statement
 * @param targetFormat - Target database format
 * @returns SQL with converted identifier quotes
 *
 * @example
 * // SQLite → MySQL
 * convertIdentifierQuotes('CREATE TABLE "users" ("id" INTEGER)', 'mysql')
 * // Returns: 'CREATE TABLE `users` (`id` INTEGER)'
 *
 * @example
 * // MySQL → PostgreSQL
 * convertIdentifierQuotes('CREATE TABLE `users` (`id` INT)', 'postgresql')
 * // Returns: 'CREATE TABLE "users" ("id" INT)'
 */
export function convertIdentifierQuotes(sql: string, targetFormat: DatabaseFormat): string {
  if (targetFormat === 'mysql') {
    // Double quotes → backticks
    // Pattern: "word_characters" → `word_characters`
    return sql.replace(/"(\w+)"/g, '`$1`');
  } else if (targetFormat === 'postgresql' || targetFormat === 'sqlite') {
    // Backticks → double quotes
    // Pattern: `alphanumeric_.-` → "alphanumeric_.-"
    // Smart replacement: only identifier chars (not string literals)
    return sql.replace(/`([a-zA-Z0-9_\.\-]+)`/g, '"$1"');
  }
  return sql;
}

/**
 * Convert autoincrement syntax between databases
 *
 * Autoincrement variations:
 * - SQLite: AUTOINCREMENT (with INTEGER PRIMARY KEY)
 * - MySQL: AUTO_INCREMENT
 * - PostgreSQL: SERIAL / GENERATED BY DEFAULT AS IDENTITY / GENERATED ALWAYS AS IDENTITY
 *
 * @param sql - SQL statement
 * @param sourceFormat - Source database format
 * @param targetFormat - Target database format
 * @returns SQL with converted autoincrement syntax
 *
 * @example
 * // SQLite → MySQL
 * convertAutoIncrement('id INTEGER PRIMARY KEY AUTOINCREMENT', 'sqlite', 'mysql')
 * // Returns: 'id INTEGER PRIMARY KEY AUTO_INCREMENT'
 *
 * @example
 * // SQLite → PostgreSQL (allow explicit ID values during import)
 * convertAutoIncrement('id INTEGER AUTOINCREMENT', 'sqlite', 'postgresql')
 * // Returns: 'id INTEGER GENERATED BY DEFAULT AS IDENTITY'
 *
 * @example
 * // MySQL → SQLite
 * convertAutoIncrement('id INT AUTO_INCREMENT', 'mysql', 'sqlite')
 * // Returns: 'id INT AUTOINCREMENT'
 */
export function convertAutoIncrement(
  sql: string,
  sourceFormat: DatabaseFormat,
  targetFormat: DatabaseFormat
): string {
  if (sourceFormat === 'sqlite' && targetFormat === 'mysql') {
    // SQLite → MySQL: AUTOINCREMENT → AUTO_INCREMENT
    return sql.replace(/AUTOINCREMENT/gi, 'AUTO_INCREMENT');
  } else if (sourceFormat === 'sqlite' && targetFormat === 'postgresql') {
    // SQLite → PostgreSQL: Two patterns
    // 1. INTEGER PRIMARY KEY AUTOINCREMENT → SERIAL PRIMARY KEY
    sql = sql.replace(/INTEGER\s+PRIMARY\s+KEY\s+AUTOINCREMENT/gi, 'SERIAL PRIMARY KEY');
    // 2. AUTOINCREMENT → GENERATED BY DEFAULT AS IDENTITY (allows explicit values)
    sql = sql.replace(/AUTOINCREMENT/gi, 'GENERATED BY DEFAULT AS IDENTITY');
    return sql;
  } else if (sourceFormat === 'mysql' && targetFormat === 'sqlite') {
    // MySQL → SQLite: AUTO_INCREMENT → AUTOINCREMENT
    return sql.replace(/AUTO_INCREMENT/gi, 'AUTOINCREMENT');
  } else if (sourceFormat === 'mysql' && targetFormat === 'postgresql') {
    // MySQL → PostgreSQL: AUTO_INCREMENT → GENERATED ALWAYS AS IDENTITY
    return sql.replace(/AUTO_INCREMENT/gi, 'GENERATED ALWAYS AS IDENTITY');
  } else if (sourceFormat === 'postgresql' && targetFormat === 'sqlite') {
    // PostgreSQL → SQLite: SERIAL / GENERATED → AUTOINCREMENT
    sql = sql.replace(/SERIAL/gi, 'INTEGER');
    sql = sql.replace(/GENERATED\s+(?:ALWAYS|BY\s+DEFAULT)\s+AS\s+IDENTITY/gi, 'AUTOINCREMENT');
    return sql;
  } else if (sourceFormat === 'postgresql' && targetFormat === 'mysql') {
    // PostgreSQL → MySQL: SERIAL / GENERATED → AUTO_INCREMENT
    sql = sql.replace(/SERIAL/gi, 'INT');
    sql = sql.replace(/GENERATED\s+(?:ALWAYS|BY\s+DEFAULT)\s+AS\s+IDENTITY/gi, 'AUTO_INCREMENT');
    return sql;
  }
  return sql;
}

/**
 * Convert timestamp/datetime functions between databases
 *
 * Timestamp function variations:
 * - SQLite: unixepoch(), datetime(ts, 'unixepoch')
 * - MySQL: UNIX_TIMESTAMP(), FROM_UNIXTIME(ts)
 * - PostgreSQL: extract(epoch from now()), to_timestamp(ts)
 *
 * @param sql - SQL statement
 * @param targetFormat - Target database format
 * @returns SQL with converted timestamp functions
 *
 * @example
 * // SQLite → MySQL
 * convertTimestampFunctions("SELECT unixepoch(), datetime(ts, 'unixepoch')", 'mysql')
 * // Returns: "SELECT UNIX_TIMESTAMP(), FROM_UNIXTIME(ts)"
 *
 * @example
 * // SQLite → PostgreSQL
 * convertTimestampFunctions("SELECT unixepoch()", 'postgresql')
 * // Returns: "SELECT extract(epoch from now())::integer"
 */
export function convertTimestampFunctions(sql: string, targetFormat: DatabaseFormat): string {
  if (targetFormat === 'mysql') {
    // SQLite → MySQL timestamp functions
    // Special handling for DEFAULT clauses - need CAST wrapper for type safety
    sql = sql.replace(/DEFAULT\s*\(\s*unixepoch\(\)\s*\)/gi, 'DEFAULT (CAST(UNIX_TIMESTAMP() AS SIGNED))');
    sql = sql.replace(/DEFAULT\s*\(\s*strftime\s*\(\s*['"]%s['"]\s*,\s*['"]now['"]\s*\)\s*\)/gi, 'DEFAULT (CAST(UNIX_TIMESTAMP() AS SIGNED))');

    // Regular conversions (non-DEFAULT contexts)
    sql = sql.replace(/unixepoch\(\)/g, 'UNIX_TIMESTAMP()');
    sql = sql.replace(/datetime\(([^,)]+),\s*'unixepoch'\)/g, 'FROM_UNIXTIME($1)');
    // strftime('%s', 'now') → UNIX_TIMESTAMP()
    sql = sql.replace(/strftime\s*\(\s*['"]%s['"]\s*,\s*['"]now['"]\s*\)/gi, 'UNIX_TIMESTAMP()');
    return sql;
  } else if (targetFormat === 'postgresql') {
    // SQLite/MySQL → PostgreSQL timestamp functions
    sql = sql.replace(/unixepoch\(\)/g, 'extract(epoch from now())::integer');
    sql = sql.replace(/datetime\(([^,)]+),\s*'unixepoch'\)/g, 'to_timestamp($1)');
    sql = sql.replace(/UNIX_TIMESTAMP\(\)/g, 'extract(epoch from now())::integer');
    sql = sql.replace(/FROM_UNIXTIME\(([^)]+)\)/g, 'to_timestamp($1)');
    // strftime('%s', 'now') → extract(epoch from now())::integer
    sql = sql.replace(/strftime\s*\(\s*['"]%s['"]\s*,\s*['"]now['"]\s*\)/gi, 'extract(epoch from now())::integer');
    return sql;
  } else if (targetFormat === 'sqlite') {
    // MySQL/PostgreSQL → SQLite timestamp functions
    sql = sql.replace(/UNIX_TIMESTAMP\(\)/g, 'unixepoch()');
    sql = sql.replace(/extract\(epoch from now\(\)\)::integer/g, 'unixepoch()');
    sql = sql.replace(/FROM_UNIXTIME\(([^)]+)\)/g, "datetime($1, 'unixepoch')");
    sql = sql.replace(/to_timestamp\(([^)]+)\)/g, "datetime($1, 'unixepoch')");
    return sql;
  }
  return sql;
}

/**
 * Convert boolean default values between databases
 *
 * Boolean default variations:
 * - SQLite: 0/1 or '0'/'1' (stored as INTEGER or TEXT)
 * - MySQL: 0/1 or FALSE/TRUE (TINYINT or BOOLEAN)
 * - PostgreSQL: false/true or FALSE/TRUE (native BOOLEAN)
 *
 * @param sql - SQL statement
 * @param targetFormat - Target database format
 * @returns SQL with converted boolean defaults
 *
 * @example
 * // SQLite → PostgreSQL
 * convertBooleanDefaults("is_active BOOLEAN default '0'", 'postgresql')
 * // Returns: "is_active BOOLEAN default false"
 *
 * @example
 * // SQLite → PostgreSQL (numeric)
 * convertBooleanDefaults("is_active BOOLEAN default 1", 'postgresql')
 * // Returns: "is_active BOOLEAN default true"
 */
export function convertBooleanDefaults(sql: string, targetFormat: DatabaseFormat): string {
  if (targetFormat === 'postgresql') {
    // Convert string boolean defaults: '0' → false, '1' → true
    sql = sql.replace(/boolean\s+default\s+'0'/gi, 'boolean default false');
    sql = sql.replace(/boolean\s+default\s+'1'/gi, 'boolean default true');
    // Convert numeric boolean defaults: 0 → false, 1 → true
    sql = sql.replace(/boolean\s+default\s+0\b/gi, 'boolean default false');
    sql = sql.replace(/boolean\s+default\s+1\b/gi, 'boolean default true');
    return sql;
  }
  return sql;
}

/**
 * Convert data type keywords between databases
 *
 * Type conversions:
 * - SQLite TEXT → MySQL VARCHAR(255) (when used with DEFAULT or NOT NULL)
 * - SQLite TEXT PRIMARY KEY → MySQL VARCHAR(191) PRIMARY KEY (MariaDB 10.5 compatibility)
 * - SQLite TEXT UNIQUE → MySQL VARCHAR(191) UNIQUE (indexes require VARCHAR)
 * - SQLite TEXT NOT NULL → MySQL VARCHAR(255) NOT NULL (for FK columns)
 * - SQLite datetime → PostgreSQL TIMESTAMP
 * - MySQL TEXT → VARCHAR for compatibility
 *
 * MySQL/MariaDB limitations:
 * - TEXT columns cannot be used in PRIMARY KEY, UNIQUE, or indexes without prefix length
 * - TEXT columns cannot have DEFAULT values
 * - VARCHAR(191) is safe max for utf8mb4 with InnoDB index prefix limit (768 bytes ÷ 4 bytes/char)
 *
 * @param sql - SQL statement
 * @param targetFormat - Target database format
 * @returns SQL with converted data types
 *
 * @example
 * // SQLite → MySQL (TEXT with DEFAULT not allowed in MySQL)
 * convertDataTypes("name TEXT NOT NULL default 'anonymous'", 'mysql')
 * // Returns: "name VARCHAR(255) NOT NULL default 'anonymous'"
 *
 * @example
 * // SQLite → MySQL (TEXT PRIMARY KEY not allowed in MariaDB 10.5)
 * convertDataTypes("tool_name TEXT PRIMARY KEY", 'mysql')
 * // Returns: "tool_name VARCHAR(191) PRIMARY KEY"
 *
 * @example
 * // SQLite → MySQL (TEXT UNIQUE not allowed in MySQL)
 * convertDataTypes("category_name TEXT UNIQUE NOT NULL", 'mysql')
 * // Returns: "category_name VARCHAR(191) UNIQUE NOT NULL"
 *
 * @example
 * // SQLite → MySQL (TEXT NOT NULL for FK columns)
 * convertDataTypes("tool_name TEXT NOT NULL", 'mysql')
 * // Returns: "tool_name VARCHAR(255) NOT NULL"
 *
 * @example
 * // SQLite → PostgreSQL
 * convertDataTypes("created_at datetime", 'postgresql')
 * // Returns: "created_at TIMESTAMP"
 */
export function convertDataTypes(sql: string, targetFormat: DatabaseFormat): string {
  if (targetFormat === 'mysql') {
    // MariaDB 10.5 and MySQL don't allow TEXT columns as PRIMARY KEY
    // Convert TEXT PRIMARY KEY to VARCHAR(191) PRIMARY KEY
    // 191 is the safe max for utf8mb4 with InnoDB index prefix limit (767 bytes / 4 bytes per char)
    sql = sql.replace(/\bTEXT(\s+PRIMARY\s+KEY)/gi, 'VARCHAR(191)$1');

    // MySQL doesn't allow TEXT columns in UNIQUE constraints
    // Convert TEXT UNIQUE to VARCHAR(191) UNIQUE
    sql = sql.replace(/\bTEXT(\s+UNIQUE)/gi, 'VARCHAR(191)$1');

    // MySQL doesn't allow TEXT columns in indexes (including FOREIGN KEY references)
    // Convert TEXT NOT NULL (commonly used in FK columns) to VARCHAR(255) NOT NULL
    // This must come BEFORE the default pattern to avoid conflicts
    sql = sql.replace(/\bTEXT(\s+NOT\s+NULL)(?!\s+default)/gi, 'VARCHAR(255)$1');

    // MySQL doesn't allow DEFAULT values on TEXT columns
    // Convert TEXT with defaults to VARCHAR(255)
    // Pattern: TEXT followed by optional NOT NULL, then default
    sql = sql.replace(/\bTEXT(\s+(?:NOT\s+NULL\s+)?default\s+[^,\)]+)/gi, 'VARCHAR(255)$1');

    return sql;
  } else if (targetFormat === 'postgresql') {
    // Convert datetime → TIMESTAMP
    sql = sql.replace(/\bdatetime\b/gi, 'TIMESTAMP');
    return sql;
  }
  return sql;
}

/**
 * Remove CHECK constraints (not well-supported in some databases)
 *
 * CHECK constraints with nested parentheses (e.g., `col` IN ('a', 'b'))
 * are not consistently supported across all databases, especially MariaDB 10.5.
 *
 * Pattern matches: CHECK (...) including nested parentheses
 * Example: check (`status` in ('active', 'inactive'))
 *
 * @param sql - SQL statement
 * @returns SQL with CHECK constraints removed
 *
 * @example
 * removeCheckConstraints("CREATE TABLE t (status TEXT check (status in ('a', 'b')))")
 * // Returns: "CREATE TABLE t (status TEXT )"
 *
 * @example
 * // Complex nested parentheses
 * removeCheckConstraints("id INT check (id > 0), name TEXT check (length(name) > 0)")
 * // Returns: "id INT , name TEXT "
 */
export function removeCheckConstraints(sql: string): string {
  // Pattern: \s+check\s*\( matches " check ("
  // [^()]* matches non-parenthesis characters
  // (?:\([^()]*\)[^()]*)* handles one level of nested parentheses
  // Example: check (col in ('a', 'b')) where ('a', 'b') are nested parens
  return sql.replace(/\s+check\s*\([^()]*(?:\([^()]*\)[^()]*)*\)/gi, '');
}

/**
 * Remove SQLite-specific DEFAULT functions (strftime, etc.)
 *
 * SQLite supports complex DEFAULT expressions using functions like strftime(),
 * which are not portable to MySQL/PostgreSQL. These are replaced with simple defaults.
 *
 * @param sql - SQL statement
 * @returns SQL with SQLite DEFAULT functions replaced with 'default 0'
 *
 * @example
 * // Parenthesized strftime
 * removeSqliteDefaultFunctions("created_at INTEGER default (strftime('%s', 'now'))")
 * // Returns: "created_at INTEGER default 0"
 *
 * @example
 * // Bare strftime
 * removeSqliteDefaultFunctions("created_at INTEGER default strftime('%s', 'now')")
 * // Returns: "created_at INTEGER default 0"
 */
export function removeSqliteDefaultFunctions(sql: string): string {
  // Pattern 1: default (strftime(...))
  sql = sql.replace(/default\s*\(strftime\([^)]+\)\)/gi, 'default 0');
  // Pattern 2: default strftime(...)
  sql = sql.replace(/default\s+strftime\([^)]+\)/gi, 'default 0');
  return sql;
}
