// sql-dump-converters.ts - Shared SQL syntax conversion functions

export type DatabaseFormat = 'mysql' | 'postgresql' | 'sqlite';

/**
 * Convert identifier quotes between database formats
 *
 * Database-specific identifier quoting:
 * - MySQL: backticks `identifier`
 * - PostgreSQL: double quotes "identifier"
 * - SQLite: double quotes "identifier" (also supports backticks)
 *
 * @param sql - SQL statement
 * @param targetFormat - Target database format
 * @returns SQL with converted identifier quotes
 *
 * @example
 * // SQLite → MySQL
 * convertIdentifierQuotes('CREATE TABLE "users" ("id" INTEGER)', 'mysql')
 * // Returns: 'CREATE TABLE `users` (`id` INTEGER)'
 *
 * @example
 * // MySQL → PostgreSQL
 * convertIdentifierQuotes('CREATE TABLE `users` (`id` INT)', 'postgresql')
 * // Returns: 'CREATE TABLE "users" ("id" INT)'
 */
export function convertIdentifierQuotes(sql: string, targetFormat: DatabaseFormat): string {
  if (targetFormat === 'mysql') {
    // Double quotes → backticks
    // Pattern: "word_characters" → `word_characters`
    return sql.replace(/"(\w+)"/g, '`$1`');
  } else if (targetFormat === 'postgresql' || targetFormat === 'sqlite') {
    // Backticks → double quotes
    // Pattern: `alphanumeric_.-` → "alphanumeric_.-"
    // Smart replacement: only identifier chars (not string literals)
    return sql.replace(/`([a-zA-Z0-9_\.\-]+)`/g, '"$1"');
  }
  return sql;
}

/**
 * Convert autoincrement syntax between databases
 *
 * Autoincrement variations:
 * - SQLite: AUTOINCREMENT (with INTEGER PRIMARY KEY)
 * - MySQL: AUTO_INCREMENT
 * - PostgreSQL: SERIAL / GENERATED BY DEFAULT AS IDENTITY / GENERATED ALWAYS AS IDENTITY
 *
 * @param sql - SQL statement
 * @param sourceFormat - Source database format
 * @param targetFormat - Target database format
 * @returns SQL with converted autoincrement syntax
 *
 * @example
 * // SQLite → MySQL
 * convertAutoIncrement('id INTEGER PRIMARY KEY AUTOINCREMENT', 'sqlite', 'mysql')
 * // Returns: 'id INTEGER PRIMARY KEY AUTO_INCREMENT'
 *
 * @example
 * // SQLite → PostgreSQL (allow explicit ID values during import)
 * convertAutoIncrement('id INTEGER AUTOINCREMENT', 'sqlite', 'postgresql')
 * // Returns: 'id INTEGER GENERATED BY DEFAULT AS IDENTITY'
 *
 * @example
 * // MySQL → SQLite
 * convertAutoIncrement('id INT AUTO_INCREMENT', 'mysql', 'sqlite')
 * // Returns: 'id INT AUTOINCREMENT'
 */
export function convertAutoIncrement(
  sql: string,
  sourceFormat: DatabaseFormat,
  targetFormat: DatabaseFormat
): string {
  if (sourceFormat === 'sqlite' && targetFormat === 'mysql') {
    // SQLite → MySQL: AUTOINCREMENT → AUTO_INCREMENT
    return sql.replace(/AUTOINCREMENT/gi, 'AUTO_INCREMENT');
  } else if (sourceFormat === 'sqlite' && targetFormat === 'postgresql') {
    // SQLite → PostgreSQL: Two patterns
    // 1. INTEGER PRIMARY KEY AUTOINCREMENT → SERIAL PRIMARY KEY
    sql = sql.replace(/INTEGER\s+PRIMARY\s+KEY\s+AUTOINCREMENT/gi, 'SERIAL PRIMARY KEY');
    // 2. AUTOINCREMENT → GENERATED BY DEFAULT AS IDENTITY (allows explicit values)
    sql = sql.replace(/AUTOINCREMENT/gi, 'GENERATED BY DEFAULT AS IDENTITY');
    return sql;
  } else if (sourceFormat === 'mysql' && targetFormat === 'sqlite') {
    // MySQL → SQLite: AUTO_INCREMENT → AUTOINCREMENT
    return sql.replace(/AUTO_INCREMENT/gi, 'AUTOINCREMENT');
  } else if (sourceFormat === 'mysql' && targetFormat === 'postgresql') {
    // MySQL → PostgreSQL: AUTO_INCREMENT → GENERATED ALWAYS AS IDENTITY
    return sql.replace(/AUTO_INCREMENT/gi, 'GENERATED ALWAYS AS IDENTITY');
  } else if (sourceFormat === 'postgresql' && targetFormat === 'sqlite') {
    // PostgreSQL → SQLite: SERIAL / GENERATED → AUTOINCREMENT
    sql = sql.replace(/SERIAL/gi, 'INTEGER');
    sql = sql.replace(/GENERATED\s+(?:ALWAYS|BY\s+DEFAULT)\s+AS\s+IDENTITY/gi, 'AUTOINCREMENT');
    return sql;
  } else if (sourceFormat === 'postgresql' && targetFormat === 'mysql') {
    // PostgreSQL → MySQL: SERIAL / GENERATED → AUTO_INCREMENT
    sql = sql.replace(/SERIAL/gi, 'INT');
    sql = sql.replace(/GENERATED\s+(?:ALWAYS|BY\s+DEFAULT)\s+AS\s+IDENTITY/gi, 'AUTO_INCREMENT');
    return sql;
  }
  return sql;
}

/**
 * Convert timestamp/datetime functions between databases
 *
 * Timestamp function variations:
 * - SQLite: unixepoch(), datetime(ts, 'unixepoch')
 * - MySQL: UNIX_TIMESTAMP(), FROM_UNIXTIME(ts)
 * - PostgreSQL: extract(epoch from now()), to_timestamp(ts)
 *
 * @param sql - SQL statement
 * @param targetFormat - Target database format
 * @returns SQL with converted timestamp functions
 *
 * @example
 * // SQLite → MySQL
 * convertTimestampFunctions("SELECT unixepoch(), datetime(ts, 'unixepoch')", 'mysql')
 * // Returns: "SELECT UNIX_TIMESTAMP(), FROM_UNIXTIME(ts)"
 *
 * @example
 * // SQLite → PostgreSQL
 * convertTimestampFunctions("SELECT unixepoch()", 'postgresql')
 * // Returns: "SELECT extract(epoch from now())::integer"
 */
export function convertTimestampFunctions(sql: string, targetFormat: DatabaseFormat): string {
  if (targetFormat === 'mysql') {
    // SQLite → MySQL timestamp functions
    sql = sql.replace(/unixepoch\(\)/g, 'UNIX_TIMESTAMP()');
    sql = sql.replace(/datetime\(([^,)]+),\s*'unixepoch'\)/g, 'FROM_UNIXTIME($1)');
    return sql;
  } else if (targetFormat === 'postgresql') {
    // SQLite/MySQL → PostgreSQL timestamp functions
    sql = sql.replace(/unixepoch\(\)/g, 'extract(epoch from now())::integer');
    sql = sql.replace(/datetime\(([^,)]+),\s*'unixepoch'\)/g, 'to_timestamp($1)');
    sql = sql.replace(/UNIX_TIMESTAMP\(\)/g, 'extract(epoch from now())::integer');
    sql = sql.replace(/FROM_UNIXTIME\(([^)]+)\)/g, 'to_timestamp($1)');
    return sql;
  } else if (targetFormat === 'sqlite') {
    // MySQL/PostgreSQL → SQLite timestamp functions
    sql = sql.replace(/UNIX_TIMESTAMP\(\)/g, 'unixepoch()');
    sql = sql.replace(/extract\(epoch from now\(\)\)::integer/g, 'unixepoch()');
    sql = sql.replace(/FROM_UNIXTIME\(([^)]+)\)/g, "datetime($1, 'unixepoch')");
    sql = sql.replace(/to_timestamp\(([^)]+)\)/g, "datetime($1, 'unixepoch')");
    return sql;
  }
  return sql;
}

/**
 * Convert boolean default values between databases
 *
 * Boolean default variations:
 * - SQLite: 0/1 or '0'/'1' (stored as INTEGER or TEXT)
 * - MySQL: 0/1 or FALSE/TRUE (TINYINT or BOOLEAN)
 * - PostgreSQL: false/true or FALSE/TRUE (native BOOLEAN)
 *
 * @param sql - SQL statement
 * @param targetFormat - Target database format
 * @returns SQL with converted boolean defaults
 *
 * @example
 * // SQLite → PostgreSQL
 * convertBooleanDefaults("is_active BOOLEAN default '0'", 'postgresql')
 * // Returns: "is_active BOOLEAN default false"
 *
 * @example
 * // SQLite → PostgreSQL (numeric)
 * convertBooleanDefaults("is_active BOOLEAN default 1", 'postgresql')
 * // Returns: "is_active BOOLEAN default true"
 */
export function convertBooleanDefaults(sql: string, targetFormat: DatabaseFormat): string {
  if (targetFormat === 'postgresql') {
    // Convert string boolean defaults: '0' → false, '1' → true
    sql = sql.replace(/boolean\s+default\s+'0'/gi, 'boolean default false');
    sql = sql.replace(/boolean\s+default\s+'1'/gi, 'boolean default true');
    // Convert numeric boolean defaults: 0 → false, 1 → true
    sql = sql.replace(/boolean\s+default\s+0\b/gi, 'boolean default false');
    sql = sql.replace(/boolean\s+default\s+1\b/gi, 'boolean default true');
    return sql;
  }
  return sql;
}

/**
 * Convert data type keywords between databases
 *
 * Type conversions:
 * - SQLite TEXT → MySQL VARCHAR(255) (when used with DEFAULT)
 * - SQLite datetime → PostgreSQL TIMESTAMP
 * - MySQL TEXT → VARCHAR for compatibility
 *
 * @param sql - SQL statement
 * @param targetFormat - Target database format
 * @returns SQL with converted data types
 *
 * @example
 * // SQLite → MySQL (TEXT with DEFAULT not allowed in MySQL)
 * convertDataTypes("name TEXT NOT NULL default 'anonymous'", 'mysql')
 * // Returns: "name VARCHAR(255) NOT NULL default 'anonymous'"
 *
 * @example
 * // SQLite → PostgreSQL
 * convertDataTypes("created_at datetime", 'postgresql')
 * // Returns: "created_at TIMESTAMP"
 */
export function convertDataTypes(sql: string, targetFormat: DatabaseFormat): string {
  if (targetFormat === 'mysql') {
    // MySQL doesn't allow DEFAULT values on TEXT columns
    // Convert TEXT with defaults to VARCHAR(255)
    // Pattern: TEXT followed by optional NOT NULL, then default
    sql = sql.replace(/\bTEXT(\s+(?:NOT\s+NULL\s+)?default\s+[^,\)]+)/gi, 'VARCHAR(255)$1');
    return sql;
  } else if (targetFormat === 'postgresql') {
    // Convert datetime → TIMESTAMP
    sql = sql.replace(/\bdatetime\b/gi, 'TIMESTAMP');
    return sql;
  }
  return sql;
}

/**
 * Remove CHECK constraints (not well-supported in some databases)
 *
 * CHECK constraints with nested parentheses (e.g., `col` IN ('a', 'b'))
 * are not consistently supported across all databases, especially MariaDB 10.5.
 *
 * Pattern matches: CHECK (...) including nested parentheses
 * Example: check (`status` in ('active', 'inactive'))
 *
 * @param sql - SQL statement
 * @returns SQL with CHECK constraints removed
 *
 * @example
 * removeCheckConstraints("CREATE TABLE t (status TEXT check (status in ('a', 'b')))")
 * // Returns: "CREATE TABLE t (status TEXT )"
 *
 * @example
 * // Complex nested parentheses
 * removeCheckConstraints("id INT check (id > 0), name TEXT check (length(name) > 0)")
 * // Returns: "id INT , name TEXT "
 */
export function removeCheckConstraints(sql: string): string {
  // Pattern: \s+check\s*\( matches " check ("
  // [^()]* matches non-parenthesis characters
  // (?:\([^()]*\)[^()]*)* handles one level of nested parentheses
  // Example: check (col in ('a', 'b')) where ('a', 'b') are nested parens
  return sql.replace(/\s+check\s*\([^()]*(?:\([^()]*\)[^()]*)*\)/gi, '');
}

/**
 * Remove SQLite-specific DEFAULT functions (strftime, etc.)
 *
 * SQLite supports complex DEFAULT expressions using functions like strftime(),
 * which are not portable to MySQL/PostgreSQL. These are replaced with simple defaults.
 *
 * @param sql - SQL statement
 * @returns SQL with SQLite DEFAULT functions replaced with 'default 0'
 *
 * @example
 * // Parenthesized strftime
 * removeSqliteDefaultFunctions("created_at INTEGER default (strftime('%s', 'now'))")
 * // Returns: "created_at INTEGER default 0"
 *
 * @example
 * // Bare strftime
 * removeSqliteDefaultFunctions("created_at INTEGER default strftime('%s', 'now')")
 * // Returns: "created_at INTEGER default 0"
 */
export function removeSqliteDefaultFunctions(sql: string): string {
  // Pattern 1: default (strftime(...))
  sql = sql.replace(/default\s*\(strftime\([^)]+\)\)/gi, 'default 0');
  // Pattern 2: default strftime(...)
  sql = sql.replace(/default\s+strftime\([^)]+\)/gi, 'default 0');
  return sql;
}
